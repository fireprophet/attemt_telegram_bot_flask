# attemt_telegram_bot_flask
Trying to create telegram bot with admin panel on flask
Сейчас архитектура приложения (реализованная часть) выглядит так:
1.	Telegram-bot->
2.	направляет пакеты, предназначенные для нас, через настроенный webhook веб-серверу->
3.	веб-сервер направляет пакеты в unix сокет->
4.	сервис uwsgi читает свой конфиг (в котором прописан unix сокет, путь к flask приложению, окружение питона, итд) запускает точку входа в приложение (uwsgi.py), которая импортирует экземпляр класса flask, который создан в основном файле, эта единая точка входа нужна для взаимодействия веб-сервера (или взаимодействия с хостами в интернете, которые направляют нам на соответствующий порт пакеты, если мы работаем без веб-сервера) и приложения flask, создает и начинает слушать запросы в файле сокета (если работаем с веб-сервером)->
5.	запуск flask основного приложения app.bot, в котором будет создаваться объект приложения класса flask и прописан код, который запускаться в случае запроса конкретного маршрута
6.	создается экземпляр класса bot
7.	вызывается метод установки вебхука на этот экземпляр, таким образом, сервер телеграма запоминает, что все, что направляется нашему боту должно обновить объект bot
(при установке вебхука должно быть перенаправлено на указанный в параметрах вебхука ip и порт через https (телеграм бот строит такой биндинг только с прокидыванием туннеля))
8.	теперь в случае обращения к веб-серверу по маршруту (/HOOK) вызывается функция flask приложения, которая парсит объект bot и пишет их в таблицу с клиентами, готовит моментальный ответ пользователю
9.	предполагаемый UI заключается в предоставлении пользователю при старте взаимодействия ряда кнопок с городом где удобнее всего было бы прийти за авто, с производителями авто, при этом когда пользователь выбирает производителя ему предлагают выбрать модель…или другая классификация, в любом случае UI это отправка пользователю кнопок, ожидание выбора и отправка пользователю перестроенных кнопок. В библиотеке над API телеграма это реализуется через объект CallbackQueryHandler, который во всех примерах используется не с webhook, а с polling (периодическим опросом сервера телеграма). Контрибьюторы проекта предлагают создать объект Dispatcher(bot, None), который по сути сам является мини веб-сервером и затем вызывать обновления объекта бота в функциях приложения для каждого маршрута. Может начаться схватка между процессом обновляющим bot-а по установленному вебхуку и процессом dispatcher-а 
10.	Добиться устойчивой работы selenium парсера в Ubuntu TODO
11.	Добиться регулярных запусков парсера cron-ом TODO
12.	Добиться регулярного запуска TODO
13.	Добиться работоспособности flask для того чтобы реализовать там админку, с аутентификацией, в которой можно управлять работой всей системы не заходя в консоль TODO https://stackoverflow.com/questions/40246702/displaying-a-txt-file-in-my-html-using-python-flask 
14.	Реализовать отправку логов работы парсера, nginx, uwsgi, бота, активности пользователей на email TODO
15.	Написать запросы, которые готовят аналитику по срезу на сегодняшний день и в динамике TODO
16.	Реализовать отправку пользователям чата аналитики TODO
17.	Засунуть все в докер для возможности быстрого развертывания TODO
18.	Мб переделать на conversationhandler https://docs-python.ru/packages/biblioteka-python-telegram-bot-python/sozdanie-razgovorov-conversationhandler/ TODO

Маршруты:
Маршруты
/nginx/logs
/bot/logs
/bot/management
/login
/logout
/requests
/parser/logs
/parser/management – управление cron-ом
/login
/logout
/index
/offer_data
/offer_data/analytics
/parsing_data

Планируемые логи:
/var/log/uwsgi/bot.log
/var/log/nginx/access.log
/var/log/nginx/error.log
/etc/systemd/system/bot.service
/etc/nginx/sites-available/bot
/var/spool/cron/crontabs/
/var/log/cron/bot.log
